import os
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import mean_squared_error, r2_score
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

# Step 1: Load the dataset
csv_file = "house_cleaned.csv"
if not os.path.exists(csv_file):
    print(f"Dataset file {csv_file} not found.")
    exit()

df = pd.read_csv(csv_file)

# Step 2: Preprocess the data
# Clean and convert the balcony column
df['balcony'] = df['balcony'].replace('3+', '3')  # Replace '3+' with '3'
df['balcony'] = pd.to_numeric(df['balcony'], errors='coerce')  # Convert to numeric

# Select relevant columns for features and target
df = df[['price', 'price_per_sqft', 'area', 'bedRoom', 'bathroom', 'balcony']]

# Drop rows with missing values
df = df.dropna()

# Convert price from crores to actual value (if needed)
df['price'] = df['price'] * 10000000  # Convert crores to rupees

# Separate features and target variable
X = df.drop(columns=['price'])
y = df['price']

# Print shape and data info for debugging
print("Dataset shape:", df.shape)
print("\nFeature columns info:")
print(X.info())
print("\nSample of preprocessed data:")
print(X.head())

# Normalize the features
scaler = StandardScaler()
X = scaler.fit_transform(X)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Step 3: Design a neural network
model = Sequential([
    Dense(128, activation='relu', input_shape=(X_train.shape[1],)),
    Dense(64, activation='relu'),
    Dense(32, activation='relu'),
    Dense(1)  # Output layer for regression
])

# Step 4: Compile the model
model.compile(optimizer='adam', loss='mean_squared_error', metrics=['mae'])

# Step 5: Train the model
history = model.fit(
    X_train, y_train,
    epochs=100,
    batch_size=32,
    validation_split=0.2,
    verbose=1
)

# Step 6: Evaluate the model
y_pred = model.predict(X_test).flatten()

mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"\nModel Evaluation:")
print(f"Mean Squared Error: {mse:,.2f}")
print(f"Root Mean Squared Error: {np.sqrt(mse):,.2f}")
print(f"R-squared score: {r2:.4f}")

# Print some sample predictions
print("\nSample Predictions (in Crores):")
sample_indices = np.random.randint(0, len(y_test), 5)
for idx in sample_indices:
    actual = y_test.iloc[idx] / 10000000  # Convert back to crores
    predicted = y_pred[idx] / 10000000    # Convert back to crores
    print(f"Actual: {actual:.2f} Cr, Predicted: {predicted:.2f} Cr")